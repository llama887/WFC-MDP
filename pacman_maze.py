import numpy as np
import collections

class PacmanMaze:
    """
    A class that defines the reward calculation for Pacman maps generated by WFC.
    Adapted from PCGRL's binary problem reward mechanism.
    """
    
    def __init__(self):
        # Define dimensions (can be adjusted based on your actual grid size)
        self._width = 28
        self._height = 31
        
        # Define reward weights
        self._rewards = {
            "regions": 5,       # Weight for connected region count 
            "path-length": 1    # Weight for longest path length
        }
        
    def get_tile_types(self):
        """Return tile types that are considered traversable"""
        # In Pacman, the empty space " " is traversable
        return [" "]
    
    def get_stats(self, grid):
        """
        Calculate statistics for the given grid
        Args:
            grid: 2D numpy array of tile identifiers
            
        Returns:
            Dictionary with statistics about the grid
        """
        # Get locations of all traversable tiles
        traversable_locations = self._get_tile_locations(grid, self.get_tile_types())
        
        # Calculate the number of connected regions
        regions = self._calc_num_regions(grid, traversable_locations)
        
        # Calculate the longest path
        path_length = self._calc_longest_path(grid, traversable_locations)
        
        return {
            "regions": regions,
            "path-length": path_length
        }
    
    def _get_tile_locations(self, grid, tile_types):
        """
        Find all locations of specified tile types in the grid
        Args:
            grid: 2D grid of tile identifiers
            tile_types: List of tile types to find
            
        Returns:
            List of (x, y) coordinates for matching tiles
        """
        locations = []
        for y in range(len(grid)):
            for x in range(len(grid[y])):
                if grid[y][x] in tile_types:
                    locations.append((x, y))
        return locations
    
    def _calc_num_regions(self, grid, locations):
        """
        Calculate the number of connected regions in the grid
        Args:
            grid: 2D grid of tile identifiers
            locations: List of (x, y) coordinates for tiles to consider
            
        Returns:
            Number of connected regions (int)
        """
        if not locations:
            return 0
        
        # Create a copy of locations to mark visited cells
        unvisited = set(locations)
        regions = 0
        
        # Perform flood fill to find connected regions
        while unvisited:
            # Start a new region
            regions += 1
            
            # Get a starting point
            start = next(iter(unvisited))
            queue = collections.deque([start])
            unvisited.remove(start)
            
            # Flood fill this region
            while queue:
                x, y = queue.popleft()
                
                # Check 4 neighboring cells (up, down, left, right)
                neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]
                for nx, ny in neighbors:
                    if (nx, ny) in unvisited:
                        queue.append((nx, ny))
                        unvisited.remove((nx, ny))
        
        return regions
    
    def _calc_longest_path(self, grid, locations):
        """
        Calculate the longest path in the grid using BFS
        Args:
            grid: 2D grid of tile identifiers
            locations: List of (x, y) coordinates for tiles to consider
            
        Returns:
            Length of the longest path (int)
        """
        if not locations:
            return 0
        
        max_path_length = 0
        locations_set = set(locations)
        
        # Try BFS from each location to find the longest path
        for start_x, start_y in locations:
            # Use BFS to find the furthest point
            visited = {(start_x, start_y)}
            queue = collections.deque([(start_x, start_y, 0)])  # (x, y, distance)
            
            furthest_dist = 0
            furthest_point = (start_x, start_y)
            
            while queue:
                x, y, dist = queue.popleft()
                
                if dist > furthest_dist:
                    furthest_dist = dist
                    furthest_point = (x, y)
                
                # Check neighbors
                neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]
                for nx, ny in neighbors:
                    if (nx, ny) in locations_set and (nx, ny) not in visited:
                        visited.add((nx, ny))
                        queue.append((nx, ny, dist + 1))
            
            # Start BFS from the furthest point to find the actual longest path
            visited = {furthest_point}
            queue = collections.deque([(furthest_point[0], furthest_point[1], 0)])
            
            longest_in_component = 0
            
            while queue:
                x, y, dist = queue.popleft()
                longest_in_component = max(longest_in_component, dist)
                
                # Check neighbors
                neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]
                for nx, ny in neighbors:
                    if (nx, ny) in locations_set and (nx, ny) not in visited:
                        visited.add((nx, ny))
                        queue.append((nx, ny, dist + 1))
            
            max_path_length = max(max_path_length, longest_in_component)
        
        return max_path_length
